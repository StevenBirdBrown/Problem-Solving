\documentclass[twocolumn]{article}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{clrscode3e}
\usepackage{txfonts}
\usepackage{enumerate}
\usepackage{ctex}
\usepackage{txfonts}
\usepackage{fontspec-xetex}
\usepackage{float}
\geometry{top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm}
\setlength\parindent{0em}
\setmainfont{Times New Roman}
\begin{document}
	\title{问题求解（二）作业（第三周）}\author{161180162 许致明}\maketitle
	\section*{CS第一章}
	\subsection*{1.13}
	设第$i$天得到的钱为$p_i$，第$i$天拥有钱的总数为$P_i$，则：
	\[
	\begin{aligned}
		p_1&=P_1=1\\
		p_{i}&=2\cdot p_{i-1},\ i\ge 2\\
		\therefore p_i&=2^{i-1}\text{	（乘法原则）}\\
		\therefore P_n&=\sum_{i=1}^{n}2^{i-1}=2^{n}-1\text{	（加法原则）}
	\end{aligned}
	\]
	由此可得，第$20$天钱的总数为$2^{20}-1=1048575$，第$n$天钱的总数为$2^n-1$.
	\subsection*{2.5}
	\begin{enumerate}[(1)]
		\item 当$k\le n$时：
		$n^{\underline{k}}\cdot k!$
		\item 当$k>n$时，要求发出所有的水果，则有人可能得到多于一块。此时方案个数为：$n^k$.
	\end{enumerate}
	\subsection*{2.15}
	若无先后顺序，则有$(n-1)(2n-1)$种方式，若考虑先后顺序，则有$2(n-1)(2n-1)$种方式。
	\subsection*{5.4}
	$n^k$
	\subsection*{5.12}
	\begin{enumerate}[(a)]
		\item $S(n,n)=1$：将$n$个元素分为$n$类，则每个元素为一类，一类仅含一个元素。类与类之间不可区分，因此$S(n,n)=1$.\\
		$S(n,1)$：所有元素均在一个类中，因此为1.
		\item $S(n,n)=S(n-1,k-1)+k\cdot S(n-1,k)$：将$n$个元素分为$k$个类可以看作两个过程的和：
		\begin{enumerate}[1.]
			\item $n-1$个元素构成了$k-1$个类，则第$n$个元素氮素构成一个集合，即$S(n-1,k-1)$
			\item $n-1$个元素已经构成了$k$个类，则将第$n$个元素插入到任意一类中，即$k\cdot S(n-1,k)$.
		\end{enumerate}
	上述即为此等式的含义。
	\item 列表如下：
	\begin{table}[H]
		\centering
		\begin{tabular}{c|c|c|c|c|c|c}
			n/k & 1  & 2  & 3  & 4  & 5  & 6  \\ \hline
			1   & 1  &   &  &  &  &  \\ \hline
			2   & 1 &  1 &  &  &  &  \\ \hline
			3   & 1 & 3 & 1 &  &  &  \\ \hline
			4   & 1 & 7 & 6 & 1 &  &  \\ \hline
			5   & 1 & 15 & 25 & 10 & 1 &  \\ \hline
			6   & 1 & 31 & 90 & 65 & 15 & 1
		\end{tabular}
	\end{table}
	\end{enumerate}
	\subsection*{5.14}
	运行缓慢的原因是递归程序不断重复计算已经算过的数据。通过猜测并证明可以得到此递归过程的递归式解为指数函数，随着输入数据的增大，算法复杂度上升极快。\par 
	一个改进的版本如下：
	\begin{lstlisting}[language=C]
int Binom(int n, int k)
{
    int ret=1;
    if(k>n)
    {    
        printf("Error: k > n!");
        exit(1);
    }
    else
    {
        int kk=1;
        for(int i=1;i<=k;++i)
            kk*=i;
        for(int i=n;i>=n-k+1;--i)
            ret*=i;
        ret/=kk;
    }
    return ret;
}
	\end{lstlisting}
	此算法是伪多项式复杂度，对于较小的$n,k$，运行时间为$O(n)$，好于递归版本的指数复杂度。
\end{document}