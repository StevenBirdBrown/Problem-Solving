\documentclass{article}
\author{Steven}
\date{\today}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{amsthm}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\begin{document}
\setlength\parindent{0em}
\large\textbf{\emph{Chapter 12}}\\
\normalsize\textbf{12.1-2}\\
BST: $x.left\leq x$ and $x.right>x$\\
Minimum Heap: $x.left\geq x$ and $x.right\geq x$\\
It's not possible, since for a heap, its left child and right child's keys doesn't have any greater or less relationship. So only by traversing the heap for $O(n)$ time is unable to output all keys in order.\\
\textbf{12.1-5}
\begin{proof}
Building a BST using sorting algorithm based on comparing is just like sort these data. Since the lower bound of comparison-based sorting algorithm is $\Omega(nlgn)$, the lower bound of building a BST by comparison is also $\Omega(nlgn)$.
\end{proof}
\textbf{12.2-5}
\begin{proof}
Denote this Node as x, then $x.left.key\leq x.key$ and $x.right.key\geq x.key$.\\
\emph{a}.Suppose $S=SUCCESSOR(x)$, then if S.left exists, $S.left.key\leq S$, and S is located in x's right subtree. So $S.left.key\geq x.key$ and $S.left.key\leq S.key$, in this case, S.left is x's successor, which contradicts our assumption. As a result, x's successor doesn't have a left child.\\
\emph{b}.Suppose $P=PREDECESSOR(x)$, and P has a right child P.right. We have $P.key\leq x.key$ and $P.right.key\geq P.key$. Besides, P.right is located in x's left subtree. So $P.right.key\leq x.key$, in this case, P.right is the predecessor of x, which contradicts our assumption. Therefore, x's predecessor doesn't have a right child.
\end{proof}
\textbf{12.2-8}
\begin{proof}
For the first time the function PRE invoked, it takes $O(h)$ time. For the next k-1 times, it traverses adjacent k-1 nodes. There are k-2 sides connecting them, and in the traversal, each side is passed at most twice. So the total time is $O(h)+2(k-2)=O(h+k)$.
\end{proof}
\textbf{12.2-9}
\begin{proof}
If x is the left child of y, then $x.key<y.key$ and $y.right.key>y.key>x.key$.
For since x is the left child of y, all decedents in y's right subtree is larger than x and y. So y.key is the least key larger than x.key. Similarly, if x is the right child of y, y.key is the largest key than x.key.
\end{proof}
\textbf{12.3-5}
\begin{lstlisting}[language=C,numbers=left]
\end{lstlisting}
\textbf{12.1}\\
\textbf{a:}$O(h+n)$\\
\textbf{b:}
\begin{lstlisting}[language=C,numbers=left]
void Tree_Insert(tree *T, node *z)
{
    node *x = T->root, *y = NULL;
    while(x != NULL)
    {
        y = x;
        if(z->key == x->key)
        {
            if(x->b == 0)
                x = x->left;
            else
                x = x->right;
            x->b = !x->b;
        }
        else if(z->key < x->key)
            x = x->left;
        else
            x = x->right;
    }
    z->p = y;
    if(y == NULL)
        T->root = z;
    else if(z->key == y->key)
    {
        if(y->b == 0)
            y->left = z;
        else y->right = z;
        y->b = !y->b;
    }
    else if(z->key < y->key)
        y->left = z;
    else y->right = z;
}
\end{lstlisting}
\textbf{c:}
\begin{lstlisting}[language=C,numbers=left]
void Tree_Insert(tree *T, node *z)
{
    node *x = T->root, *y = NULL;
    while(x != NULL)
    {
        y = x;
        if(z->key == x->key)
        {
            z->next = x->next;
            x->next = z;
            return;
        }
        else if(z->key < x->key)
            x = x->left;
        else
            x = x->right;
    }
    z->p = y;
    if(y == NULL)
        T->root = z;
    else if(z->key == y->key)
    {
        z->next = y->next;
        y->next = z;
    }
    else if(z->key < y->key)
        y->left = z;
    else y->right = z;
}
\end{lstlisting}
\textbf{d:}
\begin{lstlisting}[language=C,numbers=left]
void Tree_Insert(tree *T, node *z)
{
    node *x = T->root, *y = NULL;
    while(x != NULL)
    {
        y = x;
        if(z->key == x->key)
        {
            if(rand()%2 == 0)
                x = x->left;
            else
                x = x->right;
        }
        else if(z->key < x->key)
            x = x->left;
        else
            x = x->right;
    }
    z->p = y;
    if(y == NULL)
        T->root = z;
    else if(z->key == y->key)
    {
        if(rand()%2 == 0)
            x = x->left;
        else
            x = x->right;
    }
    else if(z->key < y->key)
        y->left = z;
    else y->right = z;
}
\end{lstlisting}
\large\textbf{\emph{Chapter 13}}\\
\normalsize\textbf{13.1-5}
\begin{proof}
Since this tree has a certain number of black node along every way downwards, the shortest way's length is the number of black nodes. According to the theorem, red nodes can't be adjacent, and red node's child must be black, the longest is that black and red nodes come up one after another. That is twice the number of the certain number black number has along one way downwards. So the longest way is at most twice the length of the shortest one.
\end{proof}
\textbf{13.1-6}\\
According to lema 13.1, there is at most $2^{2k}-1$, at least $2^{k}-1$ inside nodes.\\
\textbf{13.1-7}\\
If black and red nodes come up one after another, and all nodes at bottom is red, the ratio at most is 2:1. If all this tree's nodes is black, the ratio at least is 0.\\
\textbf{13.2-2}
\begin{proof}
There are n nodes, then there are n-1 sides, every side can be rotated left or right, so there are n-1 possible ways of rotation.
\end{proof}
\textbf{13.3-1}\\
If that node is black, then the fifth property of a RB Tree is violated, making it much more difficult to adjust.\\
\textbf{13.3-5}
\begin{proof}
If an insertion doesn't violate any property of a RB Tree, it's obvious that this node is red. Then suppose the worst case, all of the n-1 nodes are adjusted and made black. Wherever the last node is inserted, since it's first made red, it won't violate any property. So the last node must be red. Therefore, there is at least one red node.
\end{proof}
\textbf{13.4-1}
\begin{proof}
If x is the root, then it will be made black.If x is red and is not root, the loop won't take effect, and the root remains black. If x is black and is not root, then the program will enter the loop. x.p will be made red(see line 6). After case 1, it will enter case 2, 3, 4. In case 2, x.p is the new x node and made red. Loop terminates. At last x is made black. If entering case 3, 4, (see line 18)x.p is made black, if x.p is root, it remains black. If it directly enters case 2, then x.p is replaced by x. If the new x is red, loop terminates, at last it is made black. If it directly enters case 3, 4, if x.p is root, it will made black in line 18, then in case terminates. After all, the root is still black.
\end{proof}
\textbf{13.4-2}
\begin{proof}
If x and x.p are both red, it won't enter loop. Instead, x is made black to maintain the fourth property.
\end{proof}
\textbf{13.4-7}\\
Not the same.
\begin{proof}
\end{proof}
\end{document} 