6.1-2
堆是一棵近似的完全二叉树,只有最底层可能不满,
又因为一颗具有n个节点的树高度为floor(lgn),所以
含有n个元素的堆高度为floor(lgn)
6.1-4
最小元素位于堆的最底层
6.1-7
数组非最底层元素在每层的个数分别为1,2,4,...,
2^floor(lgn)
相加得Σ(i=0,2^floor(lgn))2^i=floor(n/2)
所以叶子节点的下标分别为floor(n/2)+1,floor(n/2)+2,
...,n

6.2-2
MIN-HEAPIFY(A,i)
1  left=LEFT(i)
2  right=RIGHT(i)
3  if(left<A.heapsize and A[left]<A[i])
4 	 least = left
5  else
6 	 least = i
7  if(right<A.heapsize and A[right]<A[least])
8 	 least = right
9  if(least!=i)
10 	 exchange A[i] with A[least]
11   MIN-HEAPIFY(A,least)
与MAX-HEAPIFY相似,在最坏情况下,T(n)<=T(2n/3)+Θ(1)
T(n) = O(lgn)

6.2-5
MAX-HEAPIFY(A,i)
1  left=LEFT(i)
2  right=RIGHT(i)
3  while(left<A.heapsize and right<A.heapsize)
4      if(left<A.heapsize and A[left]<A[i])
5 	       largest = left
6      else
7 	       largest = i
8      if(right<A.heapsize and A[right]<A[least])
9 	       least = right
10     if(largest!=i)
11 	       exchange A[i] with A[largest]
12         i = largest
13     else
14         break

6.2-6
假定这样一种输入:对于此输入,在根节点调用MAX-HEAPIFY(A,1)
每次所选取的largest都是当前结点的左孩子,直至到达树的底层,
这时,函数递归共有floor(lgn)层,每层均要花费常数时间,所以,
在最坏情况下的运行时间不会少于c*lgn,即为Ω(lgn)

6.3-3
当h=0时,ceil(n/2^h+1)=ceil(n/2)为二叉树全满时底层元素个数,
成立
假设h=k>0时,高度为h的节点个数最多为ceil(n/2^h)个,下面计算在
h=k+1时高度为h的结点个数:
除底层外,此二叉树全满,则对于向上一层,元素个数为下面一层的1/2
即ceil(n/2^k)/2=ceil(n/2^(k+1))个,命题得证

6.4-2
初始:
在循环开始前,i=A.length(A.length=n),第一行的BUILD-MAX-HEAP
产生了一个最大堆,其中含有A[1..n]中第n小的元素(最大元素),A[i+1..n]
为空,包含了最大的0个元素;
保持:
循环开始前有A[1]为A[1..i]中的最大值，同时A[1]≤A[i+1]≤A[i+2]≤⋯A[n]
A[1]≤A[i+1]≤A[i+2]≤⋯A[n],这时交换A[1]和A[i]使得A[i]≤A[i+1]≤...≤A[n]
A[i]≤A[i+1]≤A[i+2]≤⋯A[n].然后将heapsize减小1,再维护最大堆的性质,
使得A[1..i-1]重新成为一个堆,这在i减1之后满足了下一遍循环的前提条件;
终止:
停止时i=1,由不变量A[i..n]有序,A[1]<=A[2]<=...<=A[n],排序完成.

6.4-4
HEAPSORT运行时间等于BUILD-MAX-HEAP函数与循环中调用n-1次
MAX-HEAPIFY(A,i)运行时间之和,而BUILD-MAX-HEAP最坏运行时间
等于MAX-HEAPIFY(A,i)最坏运行时间,建堆时和for-loop中的MAX-HEAPIFY(A,i)
都要达到最坏时间T(n)=Ω(lgn),而建堆和循环时,都进行了n次循环,
所以Ω(nlgn)/*建堆*/+Ω(nlgn)/*for-loop*/=Ω(nlgn)

6.5-5
初始:
第一次满足A[1..A.heapsize]具有最大堆性质
保持:
由于上一轮循环的交换,以A[i]为根的子树满足了最大堆的性质,但是,交换后
可能使得A[PARENT(i)]与A[i]之间的关系不满足最大堆性质,即A[PARENT(i)]<A[i]
终止:
循环条件不满足时,A[i]<=A[PARENT(i)],维护了初始i的key增加导致的堆
性质丢失.

6.5-7
先进先出队列:
i初值为1,每进队一个元素x,将i赋给x.key,i自增1,然后以key为关键字
构造优先队列
栈:
i初值为某一正整数N,每压栈一个元素x,将i赋给x.key,i自减1,然后以key
为关键字构造优先队列

6.5-9
SORT-LINKED-LIST(Node[1..k])
1  BUILD-MIN-HEAP(Node)			//使用的key是当前每个链表中的最小元素
2  for n=1 to n
3      A[i]=Node[1]
4      if Node[1].next!=NIL
5          Node[1]=Node[1].next.key
6      else
7          Node[1]=INF
8      MIN-HEAPIFY(Node[1..k])





