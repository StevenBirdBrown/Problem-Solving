10.3-5
COMPACTIFY—LIST(L)
	i=0
	k=0  
    int temp[m]={0}			//m是表的最大长度  
    while (i!=n)  
      if (L.key[i] == 0)	//0表示为空，即这个元素属于表F  
           	temp[k] = i		//如果是空值，那么记录下这个指针,保存到临时数组中  
           	k = k+1  
        	i = i+1    
    p = head
	j = 0  
    while (p!=Null)  
        if (p>=n)    
            T.key[temp[j]] = T.key[p]  
            T.next[temp[j]] = T.next[p]  
            T.prev[temp[j]] = T.prev[p]  
            T.prev[T.next[temp[j]]] = temp[j]  
            T.next[T.prev[temp[j]]] = temp[j]  
            if (head==p)    
                head=temp[j]
            j = j+1    
        p = T.next[p]    

10.4-2
Recursive:
Pre-Order-Traverse(T)
if T->key
	print T->key
	Pre-Order-Traverse(T->left)
	Pre-Order-Traverse(T->right)
	
In-Order-Traverse(T)
if T->key
	In-Order-Traverse(T->left)
	print T->key
	In-Order-Traverse(T->right)
	
Post-Order-Traverse(T)
if T->key
	Post-Order-Traverse(T->left)
	Post-Order-Traverse(T->right)
	print T->key
	
10.4-3
Non-Recursive, using array to implement a stack (In 10.1):
Pre-Order-Traverse(T)
	if root == NIL 
		return   
	s.top=-1  
	s.push(root)  
	Tree pointer p = root  
    while !s.empty()      
        print p->key   
        s.pop()  
        if  p->rchild->key != 0     
            s.push(p->rchild)   
        if  p->lchild->key != 0   
            s.push(p->lchild)    

10.4-4
Pre-Order-Traverse(T)
	if T->key
		print T->key
		Pre-Order-Traverse(T->right_child)
		Pre-Order-Traverse(T->left_sibling)

10.2
(a)COMPACT-LIST-SEARCH经过t次循环后,
达到循环退出条件key[i]>=k or i=NIL.
而COMPACT-LIST-SEARCH'的while循环的退出条件也是key[i]>=k or i=NIL,
所以两个函数经过t次循环满足相同的退出条件,
那么对于同一个已排序链表得到的结果也一样相同.
其中COMPACT-LIST-SEARCH'的for循环了t次,
那么即使while循环一次不执行,那么函数总循环次数也至少为t.

(b)for循环的运行时间O(t).由于for循环经过随机跳跃到位置i,
然后经过while循环到k,所以while循环运行时间就是i到k的距离,
其期望值为O(E[Xt]).那么总的运行时间为O(t+E[Xt]).

(c)由C.25: E[Xt]=Σ(n,i=1)r*Pr{x=r}=Σ(n,i=1)Pr{x>=r}.
RANDOM(1,n)得到每个数的概率的均为1/n. 
r=1时, x>=1经过t次循环的概率为1;
r=2时, x>=2的概率为(1-1/n)^t.
... ... ...
r=n时, x>=n的概率为(1-(n-1)/n)^t.
∴E[Xt]=Σ(n,r=1)(1-(r-1)/n)^t<=Σ(n,r=1)(1-(r-1)/n)^r.

(d)Σ(n-1,r=0)r^t<=∫(0,n)(r^t)dr<=n^(r+1)/(t+1).

(e)E[Xt]<=Σ(n,r=1)(1-r/n)^t<=∫(1,n+1)(1-r/n)^t dr
 = n/t+1-n*(t+1)^t/t+1<=n/t+1

(f)T=O(t+E[Xt])<=O(t+n/(t+1))<=O(t+n/t)

(g)当仅当t=n/t（t=√n）时,COMPACT-LIST-SEARCH'运行时间达到最小.
此时COMPACT-LIST-SEARCH运行时间为O(t)=O(√n)

(h)
